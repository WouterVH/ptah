=======
Widgets
=======

Creating and Using Simple Widgets
---------------------------------

When using the widget API by itself, the simplest way to use it is to just
instantiate it using the request:

  >>> from pyramid.testing import DummyRequest as TestRequest
  >>> from memphis import view
  >>> from memphis.form import widget
  >>> from webob.multidict import MultiDict
  >>> from zope.schema import Int

  >>> field = Int(title=u'Age')
  >>> request = TestRequest()
  >>> age = widget.Widget(field, request)

In this case we instantiated a generic widget. A full set of simple
browser-based widgets can be found in the ``browser/`` package. Since no
helper components are around to fill the attributes of the widget, we have to
do it by hand:

  >>> age.name = 'age'
  >>> age.label = u'Age'
  >>> age.value = '39'
  
  >>> age.__title__
  'Widget'
  >>> repr(age)
  "<Widget 'age'>"

The most important attributes are the "name" and the "value". The name is used
to identify the widget within the form. The value is either the value to be
manipulated or the default value. The value must be provided in the form the
widget needs it. It is the responsibility of a data converter to convert
between the widget value and the desired internal value.

Before we can render the widget, we have to register a template for the
widget. The first step is to define the template:

  >>> import tempfile
  >>> textWidgetTemplate = tempfile.mktemp('text.pt')
  >>> open(textWidgetTemplate, 'w').write('''
  ... <html xmlns="http://www.w3.org/1999/xhtml"
  ...       xmlns:tal="http://xml.zope.org/namespaces/tal"
  ...       tal:omit-tag="">
  ...    <input type="text" name="" value=""
  ...           tal:attributes="name context.name; value context.value;" />
  ... </html>
  ... ''')

Next, we have to create a template factory for the widget:

  >>> from memphis.form.pagelets import IWidgetInputView
  >>> view.registerPagelet(
  ...     IWidgetInputView,
  ...     template = view.template(textWidgetTemplate, True))

The first argument, which is also required, is the path to the template
file. An optional ``content_type`` keyword argument allows the developer to
specify the output content type, usually "text/html". Then there are five
keyword arguments that specify the discriminators of the template:

* ``context`` -- This is the context in which the widget is displayed. In a
  simple widget like the one we have now, the context is ``None``.

* ``request`` -- This discriminator allows you to specify the type of request
  for which the widget will be available. In our case this would be a browser
  request. Note that browser requests can be further broken into layer, so you
  could also specify a layer interface here.

* ``view`` -- This is the view from which the widget is used. The simple
  widget at hand, does not have a view associated with it though.

* ``field`` -- This is the field for which the widget provides a
  representation. Again, this simple widget does not use a field, so it is
  ``None``.

* ``widget`` -- This is the widget itself. With this discriminator you can
  specify for which type of widget you are providing a template.

We can now register the template factory. The name of the factory is the mode
of the widget. By default, there are two widget modes: "input" and
"display". However, since the mode is just a string, one can develop other
kinds of modes as needed for a project. The default mode is "input":

  >>> from memphis.form import interfaces
  >>> age.mode is interfaces.INPUT_MODE
  True

  >>> import zope.component

Once everything is set up, the widget is updated and then rendered:

  >>> age.update()
  >>> print age.render()
  <input type="text" name="age" value="39" />

If a value is found in the request, it takes precedence, since the user
entered the value:

  >>> age.params = MultiDict({'age': '25'})
  >>> age.update()
  >>> print age.render()
  <input type="text" name="age" value="25" />

However, there is an option to turn off all request data:

  >>> age.value = '39'
  >>> age.params = {}
  >>> age.update()
  >>> print age.render()
  <input type="text" name="age" value="39" />


Creating and Using Field Widgets
--------------------------------

An extended form of the widget allows fields to control several of the
widget's properties. Let's create a field first:

  >>> ageField = zope.schema.Int(
  ...     __name__ = 'age',
  ...     title = u'Age',
  ...     min = 0,
  ...     max = 130)

We can now use our simple widget and create a field widget from it:

  >>> ageWidget = widget.Widget(ageField, request)

Now we just have to update and render the widget:

  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" />

There is no initial value for the widget, since there is no value in the
request and the field does not provide a default. Let's now give our field a
default value and see what happens:

  >>> ageField.default = 30
  
#  >>> ageWidget.update()
#  Traceback (most recent call last):
#  ...
#  TypeError: ('Could not adapt', <Widget 'age'>,
#              <InterfaceClass memphis.form.interfaces.IDataConverter>)

In order for the widget to be able to take the field's default value and use
it to provide an initial value the widget, we need to provide a data converter
that defines how to convert from the field value to the widget value.

#  >>> from memphis.form import converter
#  >>> zope.component.provideAdapter(converter.FieldWidgetDataConverter)
#  >>> zope.component.provideAdapter(converter.FieldDataConverter)

  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" value="30" />

Again, the request value is honored above everything else:

  >>> ageWidget.params = {'age': '25'}
  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" value="25" />


Creating and Using Context Widgets
----------------------------------

When widgets represent an attribute value of an object, then this object must
be set as the context of the widget:

  >>> class Person(object):
  ...     age = 45

  >>> ageWidget.params = {}
  >>> ageWidget.content = Person()

The result is that the content value takes over precendence over the default
value:

  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" value="45" />

The content can be explicitely ignored, making the widget display the default
value again:

  >>> ageWidget.content = None
  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" value="30" />

Again, the request value is honored above everything else:

  >>> ageWidget.params = {'age': '25'}
  >>> ageWidget.content = None
  >>> ageWidget.update()
  >>> print ageWidget.render()
  <input type="text" name="age" value="25" />

  >>> ageWidget.content = Person()


Sequence Widget
---------------

A common use case in user interfaces is to ask the user to select one or more
items from a set of options/choices. The ``widget`` module provides a basic
widget implementation to support this use case.

The options available for selections are known as terms. Initially, there are
no terms:

  >>> seqField = zope.schema.List(
  ...     __name__ = 'seq',
  ...     title = u'Age')

  >>> seqWidget = widget.SequenceWidget(seqField, request)
  >>> seqWidget.name = 'seq'

  >>> seqWidget.terms is None
  True

There are two ways terms can be added, either manually or via an
adapter. Those term objects must provide ``ITerms``. There is no simple
default implementation, so we have to provide one ourselves:

  >>> from zope.schema import vocabulary
  >>> class Terms(vocabulary.SimpleVocabulary):
  ...     zope.interface.implements(interfaces.ITerms)
  ...     
  ...     def getValue(self, token):
  ...         return self.getTermByToken(token).value

  >>> terms = Terms(
  ...   [Terms.createTerm(1, 'v1', u'Value 1'),
  ...    Terms.createTerm(2, 'v2', u'Value 2'),
  ...    Terms.createTerm(3, 'v3', u'Value 3')])
  >>> seqWidget.terms = terms

Once the ``terms`` attribute is set, updating the widgets does not change the
terms:

  >>> seqWidget.update()
  >>> [term.value for term in seqWidget.terms]
  [1, 2, 3]

The value of a sequence widget is a tuple/list of term tokens. When extracting
values from the request, the values must be valid tokens, otherwise the
default value is returned:

  >>> seqWidget.params = MultiDict({'seq': 'v1'})
  >>> seqWidget.extract()
  ['v1']

  >>> seqWidget.params = MultiDict({'seq': 'v4'})
  >>> seqWidget.extract()
  <NO_VALUE>

  >>> seqWidget.params = MultiDict({'seq-empty-marker': '1'})
  >>> seqWidget.extract()
  <NO_VALUE>

Note that we also support single values being returned outside a sequence. The
extracted value is then wrapped by a tuple. This feature is useful when
integrating with third-party client frameworks that do not know about the Zope
naming conventions.

  >>> seqWidget.params = MultiDict({'seq': 'v1'})
  >>> seqWidget.extract()
  ['v1']

If the no-value token has been selected, it is returned without further
verification:

  >>> seqWidget.params = MultiDict({'seq': seqWidget.noValueToken})
  >>> seqWidget.extract()
  ['--NOVALUE--']

Since the value of the widget is a tuple of tokens, when displaying the
values, they have to be converted to the title of the term:

  >>> seqWidget.value = ('v1', 'v2')
  >>> seqWidget.displayValue
  [u'Value 1', u'Value 2']

When input forms are directly switched to display forms within the same
request, it can happen that the value contains the "--NOVALUE--" token
entry. This entry should be silently ignored:

  >>> seqWidget.value = (seqWidget.noValueToken,)
  >>> seqWidget.displayValue
  []

To demonstrate how the terms is automatically chosen by a widget, we should
instantiate a field widget. Let's do this with a choice field:

  >>> seqField = zope.schema.Choice(
  ...     title=u'Sequence Field',
  ...     vocabulary=terms)

Let's now create the field widget:

  >>> seqWidget = widget.SequenceWidget(seqField, request)
  >>> seqWidget.terms

The terms should be available as soon as the widget is updated:

  >>> seqWidget.update()
  >>> seqWidget.terms
  <memphis.form.term.ChoiceTermsVocabulary object at ...>

So that's it. Everything else is the same from then on.


Cleanup
-------

Let's not leave temporary files lying around

  >>> import os
  >>> os.remove(textWidgetTemplate)
