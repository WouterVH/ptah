============
Pyramid View
============

This doctest file shows how to use views.

  >>> import pyramid.testing
  >>> from zope import interface, component
  >>> from pyramid.interfaces import IView, IRequest

Each view should have unique class, let's create one::

  >>> from memphis import view as api

  >>> class MyView(api.View):
  ...     """Custom pagelet"""


Now this view has to be registered::

  >>> api.registerView(
  ...     name="index.html",
  ...     klass = MyView)


`klass` can be just class, it can inherits from View class or
`klass` can be None. I `klass` is None or it is not inherited from
`View` class, system constructs new unique class. If class is inherited
from View class, new class isn created, but this class can't be used
for another view.

  >>> api.registerView(
  ...     name="index1.html",
  ...     klass = MyView)
  Traceback (most recent call last):
  ...
  ValueError: Class can be used for view only once.

`registerView` function description::

  # def registerView(
  #    context=None,
  #    name='',
  #    klass=None,
  #    layer=IRequest,
  #    template='',
  #    layout='',
  #    default='',
  #    configContext=None):

`context` is context to which apply view, `context=None` means to all contexts.
`name` is name of view, it is part of url.
`klass` is custom implementation for view
`layer` is pyramid request type
`template` is path to chameleon template
`layout` is layout name to use to wrap view
`default` is this view should be default view

Let's get the view::

  >>> request = pyramid.testing.DummyRequest()

  >>> view = getPyramidView(request, object(), 'index.html')

  >>> view
  <memphis.TESTS.index.html ...>

  >>> view.context
  <object object at ...>

We can create view with template. You can use similar path as for
pyramid. Like '<<package_name>>:template.pt'

  >>> class TestView(object):
  ...     pass

  >>> unregisterTmpl('memphis.view:test.pt')

  >>> api.registerView(
  ...     name="template.html",
  ...     klass=TestView,
  ...     template=api.template('memphis.view:test.pt'))

  >>> view = getPyramidView(request, object(), 'template.html')
  >>> view
  <memphis.view.compat_pyramid.View <class 'memphis.TESTS.TestView'> ...>

  >>> view.template
  <PageTemplateFile /.../test.pt>

  >>> print view.render()
  <div>My pagelet</div>

  >>> print getPyramidView(request, object(), 'template.html', True)
  200 OK
  Content-Type: text/html; charset=UTF-8
  Content-Length: 21
  <BLANKLINE>
  <div>My pagelet</div>


Default view
------------

You can define default view name. It can be used during traversing.
Let's set default name for all objects::

  >>> api.registerDefaultView('index.html')


Full `registerDefaultView` function description::

   # def registerDefaultView(
   #    name,
   #    context = interface.Interface,
   #    layer = IRequest)

Also default view available right from pyramid routing system. Let's use
`template.html` view from previous section::

  >>> api.registerDefaultView('template.html')

  >>> print getPyramidView(request, object(), '', True)
  200 OK
  Content-Type: text/html; charset=UTF-8
  Content-Length: 21
  <BLANKLINE>
  <div>My pagelet</div>


HTTP Exceptions
---------------

You can raise http exceptions from your code and you catch them
and return as result. For example if you want redirect browser to new
location::

  >>> from webob.exc import HTTPFound

  >>> class RedirectView(object):
  ...     def update(self):
  ...         raise HTTPFound(location='/other.html')

  >>> api.registerView(
  ...     name="redirect.html",
  ...     klass=RedirectView)

  >>> getPyramidView(request, object(), 'redirect.html', True)
  <HTTPFound at ... 302 Found>

  >>> unregisterTmpl('memphis.view:test.pt')

pyramidView directive
---------------------

Its possible to use decorator style registration, but class has to be
inherited from View::

  >>> from memphis import view
  >>> class View(view.View):
  ...     view.pyramidView(
  ...         'testview.html',
  ...         template=view.template('memphis.view:test.pt'))
  >>> reGrok()

Parameters are same except klass.

  >>> v = getPyramidView(request, object(), 'testview.html')
  >>> v
  <memphis.TESTS.testview.html object at ...>

  >>> v.template
  <PageTemplateFile /.../test.pt>

  >>> print v.render()
  <div>My pagelet</div>

  >>> reGrok()


subpath decorator
-----------------

Its possible to publish method of view.

  >>> unregisterTmpl('memphis.view:test.pt')

  >>> class ViewWithSubpath(api.View):
  ...     updated = False
  ...     
  ...     def update(self):
  ...         self.updated = True
  ...         return {'test':1}
  ...         
  ...     def render(self):
  ...         return 'ViewWithSubpath.render'
  ...     
  ...     @api.subpath()
  ...     def subpath1(self):
  ...         return 'ViewWithSubpath.subpath1'
  ...     
  ...     @api.subpath(name='test', content_type='text/plain', updateView=True)
  ...     def subpath2(self):
  ...         return 'ViewWithSubpath.subpath2'
  ...     
  ...     @api.subpath(renderer=api.json, updateView=True)
  ...     def subpath3(self):
  ...         return {'view': 'subpath3'}
  ...     
  ...     @api.subpath(template=api.template('memphis.view:test.pt'),
  ...                  updateView=True)
  ...     def subpath4(self):
  ...         return {}
  ...     
  ...     @api.subpath()
  ...     def subpath5(self):
  ...         raise HTTPFound(location='/')

  >>> api.registerView(
  ...     name="view",
  ...     klass = ViewWithSubpath)

  >>> request.subpath = ()
  >>> view = getPyramidView(request, object(), 'view')
  >>> print view()
  200 OK
  Content-Type: text/html; charset=UTF-8
  ...
  ViewWithSubpath.render

  >>> request.subpath = ('subpath1',)
  >>> view = getPyramidView(request, object(), 'view')
  >>> print view()
  200 OK
  ...
  ViewWithSubpath.subpath1

  >>> request.subpath = ('test',)
  >>> print view()
  200 OK
  Content-Type: text/plain; charset=UTF-8
  ...
  ViewWithSubpath.subpath2

  >>> view.updated
  True

  >>> request.subpath = ('subpath3',)
  >>> print view()
  200 OK
  Content-Type: text/json; charset=UTF-8
  ...
  {"view": "subpath3"}

  >>> request.subpath = ('subpath4',)
  >>> print view()
  200 OK
  ...
  <div>My pagelet</div>

  >>> request.subpath = ('subpath5',)
  >>> view()
  <HTTPFound at ... 302 Found>

Can't apply to function

  >>> @api.subpath()
  ... def test():
  ...     pass
  Traceback (most recent call last):
  ...
  ValueError: Can apply 'subpath' decorator only to class methods
  

view permission
---------------

  >>> from pyramid.interfaces import IAuthenticationPolicy

  >>> class SimpleAuth(object):
  ...     interface.implements(IAuthenticationPolicy)
  ...     
  ...     allowed = False
  ...     
  ...     def effective_principals(self, request):
  ...         return (1,2)
  ...     
  ...     def permits(self, context, princials, permission):
  ...         return self.allowed

  >>> component.getSiteManager().registerUtility(
  ...     SimpleAuth(), IAuthenticationPolicy)

  >>> class SecuredView(api.View):
  ...     """Custom pagelet"""
  ...     def render(self):
  ...         return 'SecuredView'

  >>> api.registerView(
  ...     name="protected.html",
  ...     klass = SecuredView, permission='Protected')

  >>> getPyramidView(request, object(), 'protected.html', call=True)
  Traceback (most recent call last):
  ...
  HTTPForbidden: Unauthorized: <class 'memphis.TESTS.protected.html'> failed permission check

  >>> SimpleAuth.allowed = True
  >>> print getPyramidView(request, object(), 'protected.html', call=True)
  200 OK
  Content-Type: text/html; charset=UTF-8
  Content-Length: 11
  <BLANKLINE>
  SecuredView

  >>> class SecuredView(api.View):
  ...     """Custom pagelet"""
  ...     def render(self):
  ...         return 'SecuredView'

  >>> api.registerView(
  ...     name="unprotected.html",
  ...     klass = SecuredView, permission='__no_permission_required__')

  >>> SimpleAuth.allowed = False
  >>> print getPyramidView(request, object(), 'unprotected.html', call=True)
  200 OK
  Content-Type: text/html; charset=UTF-8
  Content-Length: 11
  <BLANKLINE>
  SecuredView
